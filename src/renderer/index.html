<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Electron FastAPI Sidecar</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <h1>Electron FastAPI Sidecar</h1>
    <p>This application demonstrates an Electron app with a FastAPI sidecar.</p>

    <div id="api-status" class="api-status loading">
      <span class="loading-spinner"></span>
      <span class="status-text">Starting API sidecar...</span>
    </div>

    <div class="container">
      <div class="button-group">
        <button id="fetchButton" disabled>Fetch from FastAPI</button>
        <button id="fetchLogsButton" disabled>Generate Logs</button>
        <button id="clearLogsButton">Clear Logs</button>
      </div>

      <div id="result" class="result-container">
        <p>Click the button to fetch data from the FastAPI endpoint.</p>
      </div>
    </div>

    <div class="container">
      <h2>Logs</h2>
      <p>This section shows logs from all components: Python, Main, and Renderer.</p>

      <div class="log-filters">
        <label> <input type="checkbox" id="filter-python" checked /> Python </label>
        <label> <input type="checkbox" id="filter-main" checked /> Main </label>
        <label> <input type="checkbox" id="filter-renderer" checked /> Renderer </label>
        <label> <input type="checkbox" id="filter-debug" checked /> Debug </label>
        <label> <input type="checkbox" id="filter-info" checked /> Info </label>
        <label> <input type="checkbox" id="filter-warning" checked /> Warning </label>
        <label> <input type="checkbox" id="filter-error" checked /> Error </label>
      </div>

      <div id="log-container" class="log-container"></div>
    </div>

    <script>
      // Initialize the logger
      const initializeLogger = () => {
        // Set up filter event listeners
        document.querySelectorAll(".log-filters input").forEach((checkbox) => {
          checkbox.addEventListener("change", updateLogFilters);
        });

        // Check if API is available
        if (window.api && window.api.onLogEntry) {
          // Listen for log entries from the main process
          window.api.onLogEntry((entry) => {
            updateLogUI();
          });
        } else {
          console.error("API not available. Preload script may not have loaded correctly.");
          document.getElementById("log-container").innerHTML =
            "<div class='error'>Error: API not available. Preload script may not have loaded correctly.</div>";
        }
      };

      // Update log filters
      const updateLogFilters = () => {
        const filters = {
          sources: {
            python: document.getElementById("filter-python").checked,
            main: document.getElementById("filter-main").checked,
            renderer: document.getElementById("filter-renderer").checked,
          },
          levels: {
            debug: document.getElementById("filter-debug").checked,
            info: document.getElementById("filter-info").checked,
            warning: document.getElementById("filter-warning").checked,
            error: document.getElementById("filter-error").checked,
          },
        };

        // Apply filters to log entries
        document.querySelectorAll(".log-entry").forEach((entry) => {
          const source = entry.classList.contains("log-source-python")
            ? "python"
            : entry.classList.contains("log-source-main")
              ? "main"
              : "renderer";

          const level = entry.classList.contains("log-level-debug")
            ? "debug"
            : entry.classList.contains("log-level-info")
              ? "info"
              : entry.classList.contains("log-level-warning")
                ? "warning"
                : "error";

          const visible = filters.sources[source] && filters.levels[level];
          entry.style.display = visible ? "block" : "none";
        });
      };

      // Format a log entry for display
      const formatLogEntry = (entry) => {
        const timestamp = new Date(entry.timestamp).toLocaleTimeString();

        // Define colors for log levels and sources
        const levelColors = {
          debug: "#6c757d", // Gray
          info: "#0d6efd", // Blue
          warning: "#ffc107", // Yellow
          error: "#dc3545", // Red
        };

        const sourceColors = {
          python: "#20c997", // Teal
          main: "#6610f2", // Purple
          renderer: "#fd7e14", // Orange
        };

        const levelColor = levelColors[entry.level] || "#000";
        const sourceColor = sourceColors[entry.source] || "#000";

        let html = `
          <div class="log-entry log-level-${entry.level} log-source-${entry.source}">
            <span class="log-timestamp">${timestamp}</span>
            <span class="log-level" style="color: ${levelColor}">${entry.level.toUpperCase()}</span>
            <span class="log-source" style="color: ${sourceColor}">${entry.source}</span>
            <span class="log-message">${escapeHtml(entry.message)}</span>
        `;

        if (entry.data) {
          try {
            const dataStr =
              typeof entry.data === "object"
                ? JSON.stringify(entry.data, null, 2)
                : String(entry.data);
            html += `<pre class="log-data">${escapeHtml(dataStr)}</pre>`;
          } catch (e) {
            html += `<pre class="log-data">Unable to stringify data: ${e}</pre>`;
          }
        }

        if (entry.exception) {
          html += `<pre class="log-exception">${escapeHtml(entry.exception)}</pre>`;
        }

        html += "</div>";
        return html;
      };

      // Escape HTML special characters
      const escapeHtml = (text) => {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      };

      // Update the log UI with the current logs
      const updateLogUI = async () => {
        const logContainer = document.getElementById("log-container");
        if (!logContainer) return;

        // Get the scroll position
        const isScrolledToBottom =
          logContainer.scrollHeight - logContainer.clientHeight <= logContainer.scrollTop + 1;

        try {
          // Check if API is available
          if (window.api && window.api.getLogs) {
            // Get logs from the main process
            const logs = await window.api.getLogs();

            // Update the log container
            logContainer.innerHTML = logs.map(formatLogEntry).join("");

            // Apply filters
            updateLogFilters();

            // Scroll to bottom if it was at the bottom before
            if (isScrolledToBottom) {
              logContainer.scrollTop = logContainer.scrollHeight;
            }
          }
        } catch (error) {
          console.error("Error updating logs:", error);
          logContainer.innerHTML =
            "<div class='error'>Error updating logs: " + error.message + "</div>";
        }
      };

      // Log a message from the renderer
      const logFromRenderer = (level, message, data) => {
        console.log(`Renderer log (${level}): ${message}`, data || "");
        try {
          if (window.api && window.api.log) {
            window.api.log(level, message, data);
            updateLogUI();
          } else {
            console.error("API not available for logging");
          }
        } catch (error) {
          console.error(`Error logging to main process: ${error.message}`);
        }
      };

      // Start the API sidecar
      const startApiSidecar = async () => {
        try {
          const apiStatus = document.getElementById("api-status");
          const fetchButton = document.getElementById("fetchButton");
          const fetchLogsButton = document.getElementById("fetchLogsButton");

          if (window.api && window.api.startApiSidecar) {
            logFromRenderer("info", "Starting API sidecar...");
            await window.api.startApiSidecar();
            logFromRenderer("info", "API sidecar process started");

            // Set up API process exit handler
            if (window.api.onApiProcessExit) {
              window.api.onApiProcessExit((exitCode) => {
                logFromRenderer("error", `API process exited with code ${exitCode}`);

                // Update UI to show error
                apiStatus.classList.remove("loading");
                apiStatus.classList.remove("ready");
                apiStatus.classList.add("error");
                apiStatus.querySelector(".status-text").textContent =
                  `Error: API process exited with code ${exitCode}`;

                // Replace the loading spinner with an X icon
                const spinner = apiStatus.querySelector(".loading-spinner");
                if (spinner) {
                  spinner.innerHTML = "✕";
                  spinner.style.display = "flex";
                  spinner.style.justifyContent = "center";
                  spinner.style.alignItems = "center";
                  spinner.style.fontSize = "16px";
                  spinner.style.fontWeight = "bold";
                }

                // Disable buttons
                fetchButton.disabled = true;
                fetchLogsButton.disabled = true;
              });
            }

            // Poll the API health endpoint until it's ready or times out
            let attempts = 0;
            const maxAttempts = 30; // 15 seconds max wait time
            const checkInterval = 500; // Check every 500ms

            const checkApiHealth = async () => {
              if (attempts >= maxAttempts) {
                // Timeout after max attempts
                logFromRenderer("error", "API sidecar failed to start in time");
                apiStatus.classList.remove("loading");
                apiStatus.classList.add("error");
                apiStatus.querySelector(".status-text").textContent =
                  "Error: API failed to start in time";

                // Replace the loading spinner with an X icon
                const spinner = apiStatus.querySelector(".loading-spinner");
                if (spinner) {
                  spinner.innerHTML = "✕";
                  spinner.style.display = "flex";
                  spinner.style.justifyContent = "center";
                  spinner.style.alignItems = "center";
                  spinner.style.fontSize = "16px";
                  spinner.style.fontWeight = "bold";
                }
                return;
              }

              attempts++;

              if (window.api.checkApiReady) {
                const isReady = await window.api.checkApiReady();
                if (isReady) {
                  // API is ready
                  logFromRenderer("info", "API sidecar is ready");

                  // Update UI to show API is ready
                  apiStatus.classList.remove("loading");
                  apiStatus.classList.add("ready");
                  apiStatus.querySelector(".status-text").textContent = "API sidecar is ready";

                  // Replace the loading spinner with a checkmark icon
                  const spinner = apiStatus.querySelector(".loading-spinner");
                  if (spinner) {
                    spinner.innerHTML = "✓";
                    spinner.style.display = "flex";
                    spinner.style.justifyContent = "center";
                    spinner.style.alignItems = "center";
                    spinner.style.fontSize = "16px";
                    spinner.style.fontWeight = "bold";
                  }

                  // Enable buttons
                  fetchButton.disabled = false;
                  fetchLogsButton.disabled = false;
                } else {
                  // API not ready yet, try again
                  setTimeout(checkApiHealth, checkInterval);
                }
              }
            };

            // Start checking API health
            setTimeout(checkApiHealth, checkInterval);
          } else {
            console.error("API not available for starting sidecar");
            logFromRenderer("error", "API not available for starting sidecar");

            // Update UI to show error
            apiStatus.classList.remove("loading");
            apiStatus.classList.add("error");
            apiStatus.querySelector(".status-text").textContent = "Error: API not available";

            // Replace the loading spinner with an X icon
            const spinner = apiStatus.querySelector(".loading-spinner");
            if (spinner) {
              spinner.innerHTML = "✕";
              spinner.style.display = "flex";
              spinner.style.justifyContent = "center";
              spinner.style.alignItems = "center";
              spinner.style.fontSize = "16px";
              spinner.style.fontWeight = "bold";
            }
          }
        } catch (error) {
          console.error(`Error starting API sidecar: ${error.message}`);
          logFromRenderer("error", `Error starting API sidecar: ${error.message}`);

          // Update UI to show error
          const apiStatus = document.getElementById("api-status");
          apiStatus.classList.remove("loading");
          apiStatus.classList.add("error");
          apiStatus.querySelector(".status-text").textContent = `Error: ${error.message}`;

          // Replace the loading spinner with an X icon
          const spinner = apiStatus.querySelector(".loading-spinner");
          if (spinner) {
            spinner.innerHTML = "✕";
            spinner.style.display = "flex";
            spinner.style.justifyContent = "center";
            spinner.style.alignItems = "center";
            spinner.style.fontSize = "16px";
            spinner.style.fontWeight = "bold";
          }
        }
      };

      // Initialize when the DOM is loaded
      document.addEventListener("DOMContentLoaded", async () => {
        initializeLogger();
        updateLogUI();

        // Log that the renderer is ready
        logFromRenderer("info", "Renderer initialized");

        // Start the API sidecar
        await startApiSidecar();
      });

      // Fetch data button event listener
      document.getElementById("fetchButton").addEventListener("click", async () => {
        try {
          logFromRenderer("info", "Fetching data from FastAPI endpoint");

          const resultElement = document.getElementById("result");
          resultElement.innerHTML = "<p>Loading...</p>";

          // Call the fetchData function exposed by the preload script
          const data = await window.api.fetchData();

          // Log the result
          logFromRenderer("info", "Received data from FastAPI", data);

          // Display the result
          resultElement.innerHTML = `
            <pre>${JSON.stringify(data, null, 2)}</pre>
          `;
        } catch (error) {
          logFromRenderer("error", `Error fetching data: ${error.message || "Unknown error"}`);

          document.getElementById("result").innerHTML = `
            <p class="error">Error: ${error.message || "Failed to fetch data"}</p>
          `;
        }
      });

      // Fetch logs button event listener
      document.getElementById("fetchLogsButton").addEventListener("click", async () => {
        try {
          logFromRenderer("info", "Generating logs from FastAPI endpoint");

          // Call the fetchLogs function exposed by the preload script
          const data = await window.api.fetchLogs();

          // Log the result
          logFromRenderer("info", "Received logs from FastAPI", data);

          // Update the log UI
          updateLogUI();
        } catch (error) {
          logFromRenderer("error", `Error generating logs: ${error.message || "Unknown error"}`);
        }
      });

      // Clear logs button event listener
      document.getElementById("clearLogsButton").addEventListener("click", async () => {
        try {
          logFromRenderer("info", "Clearing logs");

          // Call the clearLogs function exposed by the preload script
          await window.api.clearLogs();

          // Update the log UI
          updateLogUI();
        } catch (error) {
          logFromRenderer("error", `Error clearing logs: ${error.message || "Unknown error"}`);
        }
      });
    </script>
    <div class="footer">
      <p>&copy; 2025 Electron FastAPI Sidecar Demo</p>
    </div>
  </body>
</html>
